
=======================================
File: index.html
=======================================

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>4×4 Weather Predictor</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="anonymous" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
      :root {
        --primary: #2D3436;
        --secondary: #636E72;
        --accent: #00B894;
        --background: #F7F9FC;
        --card: #FFFFFF;
        --border: #E5E9F0;
        --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.05), 0 2px 4px -2px rgb(0 0 0 / 0.05);
        --radius: 12px;
        --spacing: 1.5rem;
      }

      * { 
        margin: 0; 
        padding: 0; 
        box-sizing: border-box; 
      }

      body { 
        font-family: 'Space Grotesk', system-ui, sans-serif;
        color: var(--primary);
        background: var(--background);
        line-height: 1.5;
        -webkit-font-smoothing: antialiased;
      }

      #app {
        display: flex;
        height: 100vh;
        width: 100%;
      }

      #mapContainer {
        flex: 1;
        height: 100%;
        z-index: 1;
      }

      #sidebar {
        width: 400px;
        padding: var(--spacing);
        background: var(--background);
        overflow-y: auto;
        z-index: 2;
        box-shadow: -8px 0 16px rgba(0,0,0,0.03);
      }

      .search-box input {
        width: 100%;
        padding: 0.875rem 1rem;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        margin-bottom: var(--spacing);
        font-family: inherit;
        font-size: 0.9375rem;
        transition: all 0.2s ease;
        background: var(--card);
      }

      .search-box input:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(0,184,148,0.1);
      }

      .weather-card {
        background: var(--card);
        padding: var(--spacing);
        border-radius: var(--radius);
        margin-bottom: var(--spacing);
        box-shadow: var(--shadow);
        transition: transform 0.2s ease;
      }

      .weather-card:hover {
        transform: translateY(-2px);
      }

      .weather-card h3 {
        margin-bottom: 1rem;
        color: var(--primary);
        font-weight: 500;
        font-size: 1.125rem;
        letter-spacing: -0.02em;
      }

      .weather-row {
        display: flex;
        justify-content: space-between;
        padding: 0.75rem 0;
        border-bottom: 1px solid var(--border);
        font-size: 0.9375rem;
      }

      .weather-row:last-child {
        border-bottom: none;
        padding-bottom: 0;
      }

      .hourly-forecast {
        display: grid;
        gap: 0.75rem;
      }

      .hour-card {
        background: var(--background);
        padding: 1rem;
        border-radius: calc(var(--radius) - 4px);
        display: grid;
        grid-template-columns: 60px 1fr auto;
        gap: 1rem;
        align-items: center;
        transition: all 0.2s ease;
      }

      .hour-card:hover {
        background: var(--card);
        box-shadow: var(--shadow);
      }

      .hour-time {
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--secondary);
      }

      .conditions {
        font-size: 0.875rem;
        color: var(--secondary);
        line-height: 1.4;
      }

      .rating {
        padding: 0.5rem 0.75rem;
        border-radius: calc(var(--radius) - 4px);
        font-weight: 500;
        text-align: center;
        font-size: 0.8125rem;
        letter-spacing: 0.02em;
        text-transform: uppercase;
      }

      .rating.excellent {
        background: #00B894;
        color: white;
      }

      .rating.good {
        background: #0984E3;
        color: white;
      }

      .rating.fair {
        background: #FDCB6E;
        color: var(--primary);
      }

      .rating.poor {
        background: #D63031;
        color: white;
      }

      @media (max-width: 768px) {
        #app {
          flex-direction: column;
        }

        #mapContainer {
          height: 40vh;
        }

        #sidebar {
          width: 100%;
          height: 60vh;
        }

        .hour-card {
          grid-template-columns: 50px 1fr auto;
          padding: 0.875rem;
          gap: 0.75rem;
        }

        .weather-card {
          margin-bottom: 1rem;
          padding: 1.25rem;
        }
      }

      @media (max-width: 480px) {
        :root {
          --spacing: 1rem;
        }

        .weather-card h3 {
          font-size: 1rem;
        }

        .weather-row {
          font-size: 0.875rem;
        }

        .hour-card {
          grid-template-columns: 45px 1fr auto;
          padding: 0.75rem;
          gap: 0.5rem;
        }

        .rating {
          padding: 0.375rem 0.625rem;
          font-size: 0.75rem;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="anonymous"></script>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


=======================================
File: src/App.tsx
=======================================

import React from 'react';
import { WeatherPredictor } from './components/WeatherPredictor';
import 'leaflet/dist/leaflet.css';

function App() {
  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-white shadow-sm">
        <div className="max-w-6xl mx-auto py-4 px-4">
          <h1 className="text-3xl font-bold text-gray-900">4×4 Weather Predictor</h1>
          <p className="text-gray-600">Select a location to get wind predictions</p>
        </div>
      </header>
      <main className="py-8">
        <WeatherPredictor />
      </main>
    </div>
  );
}

export default App;


=======================================
File: src/main.tsx
=======================================

import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)


=======================================
File: src/index.css
=======================================

@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  @apply antialiased text-gray-900;
}


=======================================
File: src/main.js
=======================================

/**
 * Wing Weather - A minimalist wing foiling weather app
 * Uses OpenMeteo API for weather data and Leaflet for maps
 */

import L from 'leaflet';

// ============= Configuration =============
const CONFIG = {
  defaultLocation: { lat: 25, lng: -40, zoom: 3 },
  windRatings: {
    excellent: { min: 15, max: 25, text: 'Perfect conditions!' },
    good: { min: 12, max: 30, text: 'Good conditions' },
    fair: { min: 10, max: 35, text: 'Challenging conditions' },
    poor: { min: 0, max: 100, text: 'Not recommended' }
  },
  hours: { start: 6, end: 22 }, // 6am to 10pm
  apiEndpoints: {
    weather: 'https://api.open-meteo.com/v1/forecast',
    marine: 'https://marine-api.open-meteo.com/v1/marine'
  }
};

// ============= DOM Elements =============
const elements = {
  searchInput: document.getElementById('searchInput'),
  currentWeather: document.querySelector('#currentWeather .weather-data'),
  hourlyForecast: document.querySelector('#hourlyForecast .hourly-forecast'),
  marineWeather: document.querySelector('#marineWeather .weather-data')
};

// ============= Map Initialization =============
const map = L.map('mapContainer').setView(
  [CONFIG.defaultLocation.lat, CONFIG.defaultLocation.lng], 
  CONFIG.defaultLocation.zoom
);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: ' OpenStreetMap contributors'
}).addTo(map);

let currentMarker = null;

// ============= API Functions =============
/**
 * Fetches data from OpenMeteo API
 * @param {string} endpoint - API endpoint
 * @param {Object} params - Query parameters
 * @returns {Promise<Object>} API response
 */
async function fetchFromAPI(endpoint, params) {
  const url = new URL(endpoint);
  Object.entries(params).forEach(([key, value]) => url.searchParams.append(key, value));
  const response = await fetch(url);
  if (!response.ok) throw new Error(`API error: ${response.status}`);
  return response.json();
}

/**
 * Fetches all weather data for a location
 * @param {number} lat - Latitude
 * @param {number} lng - Longitude
 */
async function getWeatherData(lat, lng) {
  try {
    const [currentWeather, hourlyWeather, marineWeather] = await Promise.all([
      fetchFromAPI(CONFIG.apiEndpoints.weather, {
        latitude: lat,
        longitude: lng,
        current: 'temperature_2m,relative_humidity_2m,apparent_temperature,wind_speed_10m,wind_direction_10m,precipitation',
        timezone: 'auto'
      }),
      fetchFromAPI(CONFIG.apiEndpoints.weather, {
        latitude: lat,
        longitude: lng,
        hourly: 'temperature_2m,wind_speed_10m,wind_direction_10m',
        timezone: 'auto'
      }),
      fetchFromAPI(CONFIG.apiEndpoints.marine, {
        latitude: lat,
        longitude: lng,
        hourly: 'wave_height,wave_direction,wave_period',
        length_unit: 'metric',
        timezone: 'auto'
      })
    ]);

    displayCurrentWeather(currentWeather);
    displayHourlyForecast(hourlyWeather);
    displayMarineWeather(marineWeather);
  } catch (error) {
    console.error('Error fetching weather data:', error);
    handleError();
  }
}

// ============= Display Functions =============
/**
 * Displays current weather conditions
 * @param {Object} data - Current weather data
 */
function displayCurrentWeather(data) {
  const current = data.current;
  const windRating = getWingFoilingRating(current.wind_speed_10m);
  
  elements.currentWeather.innerHTML = `
    <div class="weather-row">
      <span>Wind</span>
      <span><strong>${Math.round(current.wind_speed_10m)} km/h</strong> ${getWindDirection(current.wind_direction_10m)}</span>
    </div>
    <div class="weather-row">
      <span>Temperature</span>
      <span>${Math.round(current.temperature_2m)}° / Feels ${Math.round(current.apparent_temperature)}°</span>
    </div>
    <div class="weather-row">
      <span>Conditions</span>
      <span class="rating ${windRating.rating}">${windRating.text}</span>
    </div>
  `;
}

/**
 * Displays hourly forecast with wing foiling ratings
 * @param {Object} data - Hourly forecast data
 */
function displayHourlyForecast(data) {
  const forecastHtml = Array.from({ length: CONFIG.hours.end - CONFIG.hours.start + 1 }, (_, i) => {
    const hour = CONFIG.hours.start + i;
    if (hour >= data.hourly.wind_speed_10m.length) return '';

    const windSpeed = data.hourly.wind_speed_10m[hour];
    const temp = data.hourly.temperature_2m[hour];
    const windDir = data.hourly.wind_direction_10m[hour];
    const rating = getWingFoilingRating(windSpeed);

    return `
      <div class="hour-card">
        <div class="hour-time">${formatTime(hour)}</div>
        <div class="conditions">
          <strong>${Math.round(windSpeed)} km/h</strong> ${getWindDirection(windDir)}<br>
          ${Math.round(temp)}°
        </div>
        <div class="rating ${rating.rating}">${rating.rating}</div>
      </div>
    `;
  }).join('');

  elements.hourlyForecast.innerHTML = forecastHtml;
}

/**
 * Displays marine conditions
 * @param {Object} data - Marine weather data
 */
function displayMarineWeather(data) {
  const current = {
    wave_height: data.hourly.wave_height[0],
    wave_direction: data.hourly.wave_direction[0],
    wave_period: data.hourly.wave_period[0]
  };

  elements.marineWeather.innerHTML = `
    <div class="weather-row">
      <span>Wave Height</span>
      <span>${current.wave_height.toFixed(1)}m</span>
    </div>
    <div class="weather-row">
      <span>Wave Direction</span>
      <span>${getWindDirection(current.wave_direction)}</span>
    </div>
    <div class="weather-row">
      <span>Wave Period</span>
      <span>${current.wave_period.toFixed(1)}s</span>
    </div>
  `;
}

// ============= Utility Functions =============
/**
 * Determines wing foiling conditions rating based on wind speed
 * @param {number} windSpeed - Wind speed in km/h
 * @returns {Object} Rating and description
 */
function getWingFoilingRating(windSpeed) {
  const ratings = CONFIG.windRatings;
  
  if (windSpeed >= ratings.excellent.min && windSpeed <= ratings.excellent.max) {
    return { rating: 'excellent', text: ratings.excellent.text };
  }
  if (windSpeed >= ratings.good.min && windSpeed <= ratings.good.max) {
    return { rating: 'good', text: ratings.good.text };
  }
  if (windSpeed >= ratings.fair.min && windSpeed <= ratings.fair.max) {
    return { rating: 'fair', text: ratings.fair.text };
  }
  return { rating: 'poor', text: ratings.poor.text };
}

/**
 * Converts degrees to cardinal directions
 * @param {number} degrees - Direction in degrees
 * @returns {string} Cardinal direction
 */
function getWindDirection(degrees) {
  const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE',
                     'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
  const index = Math.round(degrees / 22.5) % 16;
  return directions[index];
}

/**
 * Formats hour to 12-hour time
 * @param {number} hour - Hour in 24-hour format
 * @returns {string} Formatted time
 */
function formatTime(hour) {
  return new Intl.DateTimeFormat('en-US', {
    hour: 'numeric',
    hour12: true
  }).format(new Date().setHours(hour));
}

/**
 * Handles errors in data fetching
 */
function handleError() {
  elements.currentWeather.innerHTML = '<div class="weather-row">Error fetching weather data</div>';
  elements.hourlyForecast.innerHTML = '';
  elements.marineWeather.innerHTML = '';
}

/**
 * Updates location and fetches new weather data
 * @param {number} lat - Latitude
 * @param {number} lng - Longitude
 */
function updateLocation(lat, lng) {
  if (currentMarker) {
    map.removeLayer(currentMarker);
  }
  
  currentMarker = L.marker([lat, lng]).addTo(map);
  map.setView([lat, lng], 10);
  getWeatherData(lat, lng);
}

// ============= Event Listeners =============
// Map click handler
map.on('click', (e) => {
  const { lat, lng } = e.latlng;
  updateLocation(lat, lng);
});

// Search handler
elements.searchInput.addEventListener('keypress', async (e) => {
  if (e.key === 'Enter') {
    const query = e.target.value.trim();
    if (!query) return;

    try {
      const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`);
      const data = await response.json();
      
      if (data.length > 0) {
        const { lat, lon: lng } = data[0];
        updateLocation(parseFloat(lat), parseFloat(lng));
      }
    } catch (error) {
      console.error('Error searching location:', error);
    }
  }
});

// Initial weather data for Atlantic Ocean
updateLocation(CONFIG.defaultLocation.lat, CONFIG.defaultLocation.lng);


=======================================
File: src/components/Chart/index.tsx
=======================================

import React from 'react';
import { AreaChart, Area, XAxis, YAxis, Tooltip, ResponsiveContainer } from 'recharts';
import type { PredictionChunk } from '../WeatherPredictor/types';

interface ChartProps {
  data: PredictionChunk[];
  dataKey: 'temperature' | 'windSpeed' | 'windDirection';
  color: string;
  unit: string;
}

export function PredictionChart({ data, dataKey, color, unit }: ChartProps) {
  const formatTime = (timestamp: number) => {
    if (!timestamp || isNaN(timestamp)) return '';
    const date = new Date(timestamp);
    return date.toLocaleString('en-US', {
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
  };

  const formatTooltipTime = (timestamp: number) => {
    if (!timestamp || isNaN(timestamp)) return '';
    const date = new Date(timestamp);
    return date.toLocaleString('en-US', {
      weekday: 'short',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
  };

  const formatValue = (value: number) => {
    if (isNaN(value)) return '0' + unit;
    return Math.round(value) + unit;
  };

  const CustomTooltip = ({ active, payload, label }: any) => {
    if (active && payload && payload.length) {
      return (
        <div className="bg-white p-3 border border-gray-200 rounded shadow-lg">
          <p className="text-sm text-gray-600 mb-1">{formatTooltipTime(label)}</p>
          <p className="text-sm font-semibold">
            {dataKey.charAt(0).toUpperCase() + dataKey.slice(1)}: {formatValue(payload[0].value)}
          </p>
        </div>
      );
    }
    return null;
  };

  return (
    <div className="w-full h-[300px] bg-white p-4 rounded-lg shadow">
      <ResponsiveContainer>
        <AreaChart data={data}>
          <defs>
            <linearGradient id={`gradient-${dataKey}`} x1="0" y1="0" x2="0" y2="1">
              <stop offset="5%" stopColor={color} stopOpacity={0.8}/>
              <stop offset="95%" stopColor={color} stopOpacity={0.2}/>
            </linearGradient>
          </defs>
          <XAxis
            dataKey="timestamp"
            tickFormatter={formatTime}
            interval="preserveStartEnd"
            minTickGap={60}
            angle={-45}
            textAnchor="end"
            height={60}
          />
          <YAxis
            tickFormatter={formatValue}
            domain={dataKey === 'windDirection' ? [0, 360] : ['auto', 'auto']}
            width={60}
          />
          <Tooltip content={<CustomTooltip />} />
          <Area
            type="monotone"
            dataKey={dataKey}
            stroke={color}
            fillOpacity={1}
            fill={`url(#gradient-${dataKey})`}
            isAnimationActive={false}
          />
        </AreaChart>
      </ResponsiveContainer>
    </div>
  );
}


=======================================
File: src/components/Map/index.tsx
=======================================

import React, { useEffect, useRef } from 'react';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';

interface MapProps {
  onLocationSelect: (lat: number, lon: number) => void;
  selectedLocation?: { lat: number; lon: number };
}

export const Map: React.FC<MapProps> = ({ onLocationSelect, selectedLocation }) => {
  const mapRef = useRef<L.Map | null>(null);
  const markerRef = useRef<L.Marker | null>(null);

  useEffect(() => {
    // Initialize map
    if (!mapRef.current) {
      mapRef.current = L.map('map').setView([51.505, -0.09], 13);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
      }).addTo(mapRef.current);

      // Add click handler
      mapRef.current.on('click', (e: L.LeafletMouseEvent) => {
        const { lat, lng } = e.latlng;
        onLocationSelect(lat, lng);
      });
    }

    // Update marker if location changes
    if (selectedLocation) {
      if (markerRef.current) {
        markerRef.current.setLatLng([selectedLocation.lat, selectedLocation.lon]);
      } else {
        markerRef.current = L.marker([selectedLocation.lat, selectedLocation.lon])
          .addTo(mapRef.current);
      }
      mapRef.current.setView([selectedLocation.lat, selectedLocation.lon]);
    }

    return () => {
      if (mapRef.current) {
        mapRef.current.remove();
        mapRef.current = null;
      }
    };
  }, [selectedLocation]);

  return (
    <div id="map" className="w-full h-[400px] rounded-lg shadow-lg mb-6" />
  );
};


=======================================
File: src/components/WindTable/index.tsx
=======================================

import React from 'react';
import type { WeatherData, PredictionChunk } from '../WeatherPredictor/types';
import './styles.css';

interface WindTableProps {
  rawData: WeatherData[];
  predictions: PredictionChunk[];
}

const formatDate = (timestamp: number) => {
  try {
    const date = new Date(timestamp);
    return date.toLocaleString('en-US', {
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
  } catch (e) {
    console.error('Error formatting date:', e);
    return 'Invalid Date';
  }
};

const formatNumber = (value: number | undefined, decimals: number = 1): string => {
  if (value === undefined || value === null || isNaN(value)) {
    return '-';
  }
  return value.toFixed(decimals);
};

export const WindTable: React.FC<WindTableProps> = ({ rawData = [], predictions = [] }) => {
  // Debug logging
  console.log('WindTable received predictions:', predictions.length, 'predictions');

  if (!Array.isArray(rawData) || !Array.isArray(predictions)) {
    console.error('Invalid data type:', { rawData, predictions });
    return <div>No data available</div>;
  }

  if (rawData.length === 0) {
    return <div>No weather data available</div>;
  }

  // Get current hour timestamp (rounded down)
  const now = new Date();
  now.setMinutes(0, 0, 0);
  const currentHourTimestamp = now.getTime();

  // Sort all data by timestamp
  const sortedRawData = [...rawData].sort((a, b) => a.timestamp - b.timestamp);

  // Get the last 24 hours of historical data (for training display)
  const trainingData = sortedRawData.filter(
    d => d.timestamp < currentHourTimestamp && 
        d.timestamp >= currentHourTimestamp - 24 * 3600000
  );

  // Get the next 24 hours of forecast data
  const futureData = sortedRawData.filter(
    d => d.timestamp >= currentHourTimestamp && 
        d.timestamp < currentHourTimestamp + 24 * 3600000
  );

  // Create a map for predictions
  const predictionMap = new Map(predictions.map(p => [p.startTime, p]));

  // Combine all timestamps we want to show (last 24h + next 24h)
  const allTimestamps = new Set([
    ...trainingData.map(d => d.timestamp),
    ...futureData.map(d => d.timestamp),
    ...predictions.map(p => p.startTime)
  ]);

  const sortedTimestamps = Array.from(allTimestamps).sort((a, b) => a - b);

  return (
    <div className="wind-table-container">
      <h3>Hourly Wind Data Comparison</h3>
      <div className="table-scroll">
        <table className="wind-table">
          <thead>
            <tr>
              <th>Time</th>
              <th colSpan={4}>Raw Data</th>
              <th colSpan={4}>AI Prediction</th>
            </tr>
            <tr>
              <th></th>
              <th>Wind Speed (kts)</th>
              <th>Gusts (kts)</th>
              <th>Direction</th>
              <th>Temp (°C)</th>
              <th>Wind Speed (kts)</th>
              <th>Gusts (kts)</th>
              <th>Direction</th>
              <th>Confidence</th>
            </tr>
          </thead>
          <tbody>
            {sortedTimestamps.map((timestamp, index) => {
              const rawDataPoint = sortedRawData.find(d => d.timestamp === timestamp);
              const prediction = predictionMap.get(timestamp);
              const isTrainingData = timestamp < currentHourTimestamp;
              const isFutureData = timestamp >= currentHourTimestamp;

              return (
                <tr key={index} 
                    className={`
                      ${isTrainingData ? 'training-data' : ''}
                      ${isFutureData ? 'future-data' : ''}
                      ${prediction ? 'has-prediction' : ''}
                    `}>
                  <td>{formatDate(timestamp)}</td>
                  {rawDataPoint ? (
                    <>
                      <td>{formatNumber(rawDataPoint.windSpeed)}</td>
                      <td>{formatNumber(rawDataPoint.windGusts)}</td>
                      <td>{formatNumber(rawDataPoint.windDirection, 0)}°</td>
                      <td>{formatNumber(rawDataPoint.temperature)}</td>
                    </>
                  ) : (
                    <td colSpan={4}>No raw data</td>
                  )}
                  {prediction ? (
                    <>
                      <td>{formatNumber(prediction.windSpeed)}</td>
                      <td>{formatNumber(prediction.windGusts)}</td>
                      <td>{formatNumber(prediction.windDirection, 0)}°</td>
                      <td>{formatNumber(prediction.confidence ? prediction.confidence * 100 : undefined, 0)}%</td>
                    </>
                  ) : (
                    <td colSpan={4}>No prediction</td>
                  )}
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
      <div className="text-sm text-gray-600 mt-2">
        Training data: {trainingData.length} hours • 
        Future data: {futureData.length} hours • 
        Predictions: {predictions.length} hours
      </div>
    </div>
  );
};


=======================================
File: src/components/WindTable/styles.css
=======================================

.wind-table-container {
  margin: 1rem 0;
  overflow: hidden;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.table-scroll {
  overflow-x: auto;
  max-height: 600px;
  overflow-y: auto;
}

.wind-table {
  width: 100%;
  border-collapse: collapse;
  text-align: center;
  font-size: 0.9rem;
}

.wind-table th,
.wind-table td {
  padding: 0.5rem;
  border: 1px solid #e2e8f0;
}

.wind-table thead {
  background-color: #f8fafc;
}

.wind-table th {
  font-weight: 600;
}

.wind-table thead th {
  position: sticky;
  top: 0;
  z-index: 1;
}

.wind-table tbody tr:nth-child(even) {
  background-color: #f8f9fa;
}

.wind-table tbody tr:hover {
  background-color: #f0f0f0;
}

/* Data type styling */
.wind-table tr.training-data {
  background-color: #f0f9ff; /* Light blue for training data */
}

.wind-table tr.future-data {
  background-color: #fff7ed; /* Light orange for future data */
}

.wind-table tr.has-prediction.future-data {
  background-color: #f0fdf4; /* Light green for predictions */
}

.has-prediction {
  font-weight: 500;
}

/* Status text */
.text-sm {
  font-size: 0.875rem;
}

.text-gray-600 {
  color: #4b5563;
}

.mt-2 {
  margin-top: 0.5rem;
}

/* Responsive design */
@media (max-width: 768px) {
  .wind-table {
    font-size: 12px;
  }
  
  .wind-table th,
  .wind-table td {
    padding: 6px 8px;
  }
}


=======================================
File: src/components/WeatherPredictor/index.tsx
=======================================

import React, { useState, useCallback } from 'react';
import { WeatherPredictor as Model } from './model';
import { fetchHistoricalWeather } from '../../lib/weather';
import { PredictionChart } from '../Chart';
import { Map } from '../Map';
import { WindTable } from '../WindTable';
import type { PredictionChunk, WeatherData } from './types';

export const WeatherPredictor: React.FC = () => {
  const [isTraining, setIsTraining] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [predictions, setPredictions] = useState<PredictionChunk[]>([]);
  const [rawData, setRawData] = useState<WeatherData[]>([]);
  const [location, setLocation] = useState<{ lat: number; lon: number } | null>(null);
  const [progress, setProgress] = useState<{ epoch: number; loss: number } | null>(null);

  const handleLocationSelect = useCallback(async (lat: number, lon: number) => {
    setLocation({ lat, lon });
    setError(null);
    setPredictions([]);
    setProgress(null);
    
    try {
      setIsTraining(true);
      const weatherData = await fetchHistoricalWeather(lat, lon);
      
      // Get current hour timestamp (rounded down)
      const now = new Date();
      now.setMinutes(0, 0, 0);
      const currentHourTimestamp = now.getTime();
      
      // Split data into past and future at current hour
      const historicalData = weatherData.filter(d => d.timestamp < currentHourTimestamp);
      const futureData = weatherData.filter(d => d.timestamp >= currentHourTimestamp);
      
      // Keep all data for display
      setRawData(weatherData);
      
      const model = new Model();
      
      // Train on all available historical data
      await model.train(historicalData, (status) => {
        setProgress(status);
      });
      
      // Use the last 24 hours for prediction input
      const predictionInput = historicalData.slice(-24);
      
      // Generate predictions starting from current hour
      const newPredictions = await model.predict(predictionInput);
      
      // Align predictions with current time
      const alignedPredictions = newPredictions.map((pred, index) => ({
        ...pred,
        startTime: currentHourTimestamp + (index * 3600000) // Add hours in milliseconds
      })).slice(0, 24); // Ensure exactly 24 hours of predictions
      
      setPredictions(alignedPredictions);
      model.dispose();
    } catch (err) {
      console.error('Prediction error:', err);
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setIsTraining(false);
    }
  }, []);

  return (
    <div className="max-w-6xl mx-auto p-4">
      <div className="mb-8">
        <h2 className="text-2xl font-bold mb-4">Select Location</h2>
        <Map onLocationSelect={handleLocationSelect} selectedLocation={location} />
      </div>

      {error && (
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
          {error}
        </div>
      )}

      {isTraining && (
        <div className="mb-4">
          <div className="animate-pulse bg-blue-100 border border-blue-400 text-blue-700 px-4 py-3 rounded">
            Training model... {progress?.epoch && `Epoch ${progress.epoch}`}
          </div>
        </div>
      )}

      {location && !isTraining && !error && (
        <>
          <div className="grid grid-cols-2 gap-8 mb-8">
            <div>
              <h2 className="text-2xl font-bold mb-4">Raw Wind Speed</h2>
              <PredictionChart 
                data={rawData.slice(-24)} 
                dataKey="windSpeed" 
                color="#2563EB"
                unit="kts"
              />
            </div>
            <div>
              <h2 className="text-2xl font-bold mb-4">Predicted Wind Speed</h2>
              <PredictionChart 
                data={predictions} 
                dataKey="windSpeed" 
                color="#7C3AED"
                unit="kts"
              />
            </div>
          </div>
          
          <div className="grid grid-cols-2 gap-8 mb-8">
            <div>
              <h2 className="text-2xl font-bold mb-4">Raw Wind Direction</h2>
              <PredictionChart 
                data={rawData.slice(-24)} 
                dataKey="windDirection" 
                color="#F59E0B"
                unit="°"
              />
            </div>
            <div>
              <h2 className="text-2xl font-bold mb-4">Predicted Wind Direction</h2>
              <PredictionChart 
                data={predictions} 
                dataKey="windDirection" 
                color="#EC4899"
                unit="°"
              />
            </div>
          </div>
          
          <div className="mb-8">
            <h2 className="text-2xl font-bold mb-4">Detailed Comparison</h2>
            <WindTable predictions={predictions} rawData={rawData} />
          </div>
        </>
      )}
    </div>
  );
};


=======================================
File: src/components/WeatherPredictor/model.ts
=======================================

import * as tf from '@tensorflow/tfjs';
import type { WeatherData, PredictionChunk, ModelConfig } from './types';
import { standardizeData } from '../../lib/tf-setup';

const DEFAULT_CONFIG: ModelConfig = {
  epochs: 50,          // Increased from 20 to 50 for better training
  batchSize: 32,
  learningRate: 0.001,
  timeSteps: 24,       // Reduced to 24 hours (1 day of history)
  predictionSteps: 24  // 24 hours of predictions
};

export class WeatherPredictor {
  private model: tf.LayersModel | null = null;
  private config: ModelConfig;
  private meanStd: { mean: number[]; std: number[] } | null = null;

  constructor(config: Partial<ModelConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  private normalize(data: number[][]): number[][] {
    if (!this.meanStd) {
      const features = data[0].length;
      const mean = new Array(features).fill(0);
      const std = new Array(features).fill(0);
      
      // Calculate mean
      for (const row of data) {
        for (let i = 0; i < features; i++) {
          mean[i] += row[i];
        }
      }
      for (let i = 0; i < features; i++) {
        mean[i] /= data.length;
      }
      
      // Calculate std with better numerical stability
      for (const row of data) {
        for (let i = 0; i < features; i++) {
          std[i] += Math.pow(row[i] - mean[i], 2);
        }
      }
      for (let i = 0; i < features; i++) {
        std[i] = Math.sqrt(std[i] / data.length) + 1e-6; // Small epsilon to prevent division by zero
      }
      
      this.meanStd = { mean, std };
    }
    
    return data.map(row => 
      row.map((val, i) => (val - this.meanStd!.mean[i]) / this.meanStd!.std[i])
    );
  }

  private denormalize(data: number[][], featureIndices: number[]): number[][] {
    if (!this.meanStd) return data;
    
    return data.map(row => 
      row.map((val, i) => val * this.meanStd!.std[featureIndices[i]] + this.meanStd!.mean[featureIndices[i]])
    );
  }

  private createModel(): tf.LayersModel {
    return tf.tidy(() => {
      const model = tf.sequential();

      // Larger input layer for increased historical data
      model.add(tf.layers.dense({
        units: 256,
        inputShape: [this.config.timeSteps * 5],
        activation: 'relu'
      }));
      model.add(tf.layers.dropout({ rate: 0.2 }));

      // Additional hidden layers
      model.add(tf.layers.dense({ units: 512, activation: 'relu' }));
      model.add(tf.layers.dropout({ rate: 0.3 }));
      
      model.add(tf.layers.dense({ units: 256, activation: 'relu' }));
      model.add(tf.layers.dropout({ rate: 0.2 }));
      
      model.add(tf.layers.dense({ units: 128, activation: 'relu' }));
      model.add(tf.layers.dropout({ rate: 0.1 }));

      // Output layer
      model.add(tf.layers.dense({
        units: 3,
        activation: 'linear'
      }));

      model.compile({
        optimizer: tf.train.adam(this.config.learningRate),
        loss: 'meanSquaredError'
      });

      return model;
    });
  }

  async train(weatherData: WeatherData[], onProgress?: (status: { epoch: number; loss: number }) => void): Promise<void> {
    if (weatherData.length < this.config.timeSteps + 1) {
      throw new Error(`Insufficient data: need at least ${this.config.timeSteps + 1} points`);
    }

    try {
      // Sort data by timestamp to ensure chronological order
      const sortedData = [...weatherData].sort((a, b) => a.timestamp - b.timestamp);

      // Convert data to arrays for normalization
      const rawData = sortedData.map(d => [
        d.temperature,
        d.windSpeed,
        d.windGusts,
        d.windDirection / 360, // Normalize direction to [0, 1]
        d.humidity || 0
      ]);

      // Normalize the data
      const normalizedData = this.normalize(rawData);

      // Prepare sequences and labels with sliding window
      const sequences: number[][] = [];
      const labels: number[][] = [];

      // Use more data for training by sliding the window
      for (let i = 0; i <= normalizedData.length - this.config.timeSteps - 1; i++) {
        const sequence = normalizedData.slice(i, i + this.config.timeSteps).flat();
        const nextValues = normalizedData[i + this.config.timeSteps];
        
        sequences.push(sequence);
        labels.push([nextValues[1], nextValues[2], nextValues[3]]); // wind speed, gusts, direction
      }

      // Create tensors
      const features = tf.tensor2d(sequences);
      const targets = tf.tensor2d(labels);

      // Create and train model with more epochs and validation
      this.model = this.createModel();
      await this.model.fit(features, targets, {
        epochs: this.config.epochs,
        batchSize: this.config.batchSize,
        shuffle: true,
        validationSplit: 0.2,
        callbacks: {
          onEpochEnd: (epoch, logs) => {
            if (onProgress) {
              onProgress({
                epoch,
                loss: logs?.loss || 0
              });
            }
          }
        }
      });

      // Cleanup
      features.dispose();
      targets.dispose();

    } catch (error) {
      console.error('Training error:', error);
      throw error;
    }
  }

  async predict(inputData: WeatherData[]): Promise<PredictionChunk[]> {
    if (!this.model) {
      throw new Error('Model not trained');
    }

    try {
      const predictions: PredictionChunk[] = [];
      let currentInput = [...inputData];

      // Get current hour timestamp
      const now = new Date();
      now.setMinutes(0, 0, 0);
      const currentHourTimestamp = now.getTime();

      // Prepare initial input
      const initialRawData = currentInput.map(d => [
        d.temperature,
        d.windSpeed,
        d.windGusts,
        d.windDirection / 360,
        d.humidity || 0
      ]);

      let normalizedInput = this.normalize(initialRawData);

      // Generate predictions for 24 hours
      for (let hour = 0; hour < 24; hour++) {
        const timestamp = currentHourTimestamp + (hour * 3600000);
        
        // Prepare input tensor
        const inputSequence = normalizedInput.slice(-this.config.timeSteps).flat();
        const inputTensor = tf.tensor2d([inputSequence]);
        
        // Make prediction
        const outputTensor = this.model.predict(inputTensor) as tf.Tensor;
        const normalizedPrediction = await outputTensor.array() as number[][];
        
        // Denormalize prediction
        const denormalizedPrediction = this.denormalize(normalizedPrediction, [1, 2, 3])[0];
        
        // Calculate confidence
        const confidence = Math.max(0.08, 1 - (hour * 0.04));
        
        // Create prediction chunk
        const prediction: PredictionChunk = {
          startTime: timestamp,
          windSpeed: Math.max(0, denormalizedPrediction[0]),
          windGusts: Math.max(0, denormalizedPrediction[1]),
          windDirection: ((Math.round(denormalizedPrediction[2] * 360) % 360) + 360) % 360,
          confidence
        };
        
        predictions.push(prediction);
        
        // Update input for next prediction
        const newDataPoint = [
          normalizedInput[normalizedInput.length - 1][0], // Keep last temperature
          normalizedPrediction[0][0],
          normalizedPrediction[0][1],
          normalizedPrediction[0][2],
          normalizedInput[normalizedInput.length - 1][4]  // Keep last humidity
        ];
        
        normalizedInput = [...normalizedInput.slice(1), newDataPoint];
        
        // Cleanup tensors
        inputTensor.dispose();
        outputTensor.dispose();
      }

      return predictions;
    } catch (error) {
      console.error('Prediction error:', error);
      throw error;
    }
  }

  dispose(): void {
    this.model?.dispose();
    this.model = null;
    this.meanStd = null;
  }
}


=======================================
File: src/components/WeatherPredictor/types.ts
=======================================

export interface WeatherData {
  timestamp: number;
  temperature: number;
  windSpeed: number;
  windGusts: number;
  windDirection: number;
  humidity: number;
}

export interface PredictionChunk {
  startTime: number;
  endTime: number;
  temperature: number;
  windSpeed: number;
  windGusts: number;
  windDirection: number;
  humidity: number;
  confidence: number;
}

export interface ModelConfig {
  epochs: number;
  batchSize: number;
  learningRate: number;
  timeSteps: number; // 16 hours
  predictionSteps: number; // 4 chunks of 4 hours
}

export interface TrainingStatus {
  epoch: number;
  loss: number;
  status: 'training' | 'complete' | 'error';
}


=======================================
File: src/style.css
=======================================

:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.vanilla:hover {
  filter: drop-shadow(0 0 2em #f7df1eaa);
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}


=======================================
File: src/lib/tf-setup.ts
=======================================

import * as tf from '@tensorflow/tfjs';

export async function initializeTensorFlow() {
  // Wait for backend to be ready
  await tf.ready();
  
  // Set memory management settings
  tf.env().set('WEBGL_DELETE_TEXTURE_THRESHOLD', 0);
  tf.env().set('WEBGL_FORCE_F16_TEXTURES', false);
  
  // Log backend info
  console.log('TensorFlow.js backend:', tf.getBackend());
  console.log('WebGL max texture size:', tf.env().getNumber('WEBGL_MAX_TEXTURE_SIZE'));
  
  return tf;
}

export function standardizeData(data: tf.Tensor) {
  return tf.tidy(() => {
    const moments = tf.moments(data, 0);
    const standardized = data.sub(moments.mean).div(tf.sqrt(moments.variance.add(1e-8)));
    return standardized;
  });
}


=======================================
File: src/lib/weather.ts
=======================================

import type { WeatherData } from '../components/WeatherPredictor/types';

export async function fetchHistoricalWeather(lat: number, lon: number, hours: number = 120): Promise<WeatherData[]> {
  console.log('Fetching weather data for:', { lat, lon, hours });
  
  try {
    // Get both past data and forecast
    const response = await fetch(
      `https://api.open-meteo.com/v1/forecast?` +
      `latitude=${lat}&longitude=${lon}&` +
      `hourly=temperature_2m,relative_humidity_2m,windspeed_10m,winddirection_10m,windgusts_10m&` +
      `past_hours=${hours}&forecast_hours=48&` + // Get 5 days of historical data
      `timezone=auto`
    );

    if (!response.ok) {
      throw new Error(`Weather API error: ${response.status}`);
    }

    const data = await response.json();
    console.log('Received weather data:', data);

    if (!data.hourly || !Array.isArray(data.hourly.time)) {
      throw new Error('Invalid weather data format');
    }

    // Convert wind speed from m/s to knots
    const msToKnots = 1.94384;
    
    const weatherData = data.hourly.time.map((timestamp: string, i: number) => ({
      timestamp: new Date(timestamp).getTime(),
      temperature: data.hourly.temperature_2m[i],
      windSpeed: data.hourly.windspeed_10m[i] * msToKnots,
      windGusts: data.hourly.windgusts_10m[i] * msToKnots,
      windDirection: data.hourly.winddirection_10m[i],
      humidity: data.hourly.relative_humidity_2m[i]
    }));

    // Filter out any invalid entries
    const validData = weatherData.filter(d => 
      !isNaN(d.timestamp) && 
      !isNaN(d.windSpeed) && 
      !isNaN(d.windDirection) &&
      d.windDirection >= 0 && 
      d.windDirection <= 360
    );

    console.log('Processed weather data:', validData.length, 'valid records');
    return validData;
  } catch (error) {
    console.error('Error fetching weather data:', error);
    throw error;
  }
}

export function calculateWindQuality(windSpeed: number): {
  quality: 'poor' | 'fair' | 'good' | 'excellent';
  confidence: number;
} {
  // Convert to knots if not already
  const speed = windSpeed;
  
  if (speed < 8) return { quality: 'poor', confidence: 0.8 };
  if (speed < 12) return { quality: 'fair', confidence: 0.9 };
  if (speed < 25) return { quality: 'good', confidence: 1.0 };
  if (speed < 35) return { quality: 'excellent', confidence: 0.9 };
  return { quality: 'poor', confidence: 0.8 }; // Too strong
}

export function formatWindDirection(degrees: number): string {
  const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
  const index = Math.round(degrees / 45) % 8;
  return directions[index];
}


=======================================
File: src/counter.js
=======================================

export function setupCounter(element) {
  let counter = 0
  const setCounter = (count) => {
    counter = count
    element.innerHTML = `count is ${counter}`
  }
  element.addEventListener('click', () => setCounter(counter + 1))
  setCounter(0)
}


